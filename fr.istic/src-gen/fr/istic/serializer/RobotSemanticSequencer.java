/*
 * generated by Xtext 2.34.0
 */
package fr.istic.serializer;

import com.google.inject.Inject;
import fr.istic.services.RobotGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import robot.AND;
import robot.Add;
import robot.Backward;
import robot.Block;
import robot.CallFunction;
import robot.CallVar;
import robot.Clock;
import robot.Cm;
import robot.Condition;
import robot.Const;
import robot.Distance;
import robot.DistanceSensor;
import robot.Div;
import robot.Equals;
import robot.FALSE;
import robot.Forward;
import robot.FunctionIdentifier;
import robot.Greater;
import robot.Left;
import robot.Lesser;
import robot.Loop;
import robot.Minus;
import robot.Mm;
import robot.Mul;
import robot.NOT;
import robot.OR;
import robot.Program;
import robot.RFunction;
import robot.Right;
import robot.RobotPackage;
import robot.TRUE;
import robot.TimeSensor;
import robot.Var;
import robot.VarIdentifier;

@SuppressWarnings("all")
public class RobotSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private RobotGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == RobotPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case RobotPackage.AND:
				sequence_AND(context, (AND) semanticObject); 
				return; 
			case RobotPackage.ADD:
				sequence_Add(context, (Add) semanticObject); 
				return; 
			case RobotPackage.BACKWARD:
				sequence_Backward(context, (Backward) semanticObject); 
				return; 
			case RobotPackage.BLOCK:
				sequence_Block(context, (Block) semanticObject); 
				return; 
			case RobotPackage.CALL_FUNCTION:
				sequence_CallFunction(context, (CallFunction) semanticObject); 
				return; 
			case RobotPackage.CALL_VAR:
				sequence_CallVar(context, (CallVar) semanticObject); 
				return; 
			case RobotPackage.CLOCK:
				sequence_Clock(context, (Clock) semanticObject); 
				return; 
			case RobotPackage.CM:
				sequence_Cm(context, (Cm) semanticObject); 
				return; 
			case RobotPackage.CONDITION:
				sequence_Condition(context, (Condition) semanticObject); 
				return; 
			case RobotPackage.CONST:
				sequence_Const(context, (Const) semanticObject); 
				return; 
			case RobotPackage.DISTANCE:
				sequence_Distance(context, (Distance) semanticObject); 
				return; 
			case RobotPackage.DISTANCE_SENSOR:
				sequence_DistanceSensor(context, (DistanceSensor) semanticObject); 
				return; 
			case RobotPackage.DIV:
				sequence_Div(context, (Div) semanticObject); 
				return; 
			case RobotPackage.EQUALS:
				sequence_Equals(context, (Equals) semanticObject); 
				return; 
			case RobotPackage.FALSE:
				sequence_FALSE(context, (FALSE) semanticObject); 
				return; 
			case RobotPackage.FORWARD:
				sequence_Forward(context, (Forward) semanticObject); 
				return; 
			case RobotPackage.FUNCTION_IDENTIFIER:
				sequence_FunctionIdentifier(context, (FunctionIdentifier) semanticObject); 
				return; 
			case RobotPackage.GREATER:
				sequence_Greater(context, (Greater) semanticObject); 
				return; 
			case RobotPackage.LEFT:
				sequence_Left(context, (Left) semanticObject); 
				return; 
			case RobotPackage.LESSER:
				sequence_Lesser(context, (Lesser) semanticObject); 
				return; 
			case RobotPackage.LOOP:
				sequence_Loop(context, (Loop) semanticObject); 
				return; 
			case RobotPackage.MINUS:
				sequence_Minus(context, (Minus) semanticObject); 
				return; 
			case RobotPackage.MM:
				sequence_Mm(context, (Mm) semanticObject); 
				return; 
			case RobotPackage.MUL:
				sequence_Mul(context, (Mul) semanticObject); 
				return; 
			case RobotPackage.NOT:
				sequence_NOT(context, (NOT) semanticObject); 
				return; 
			case RobotPackage.OR:
				sequence_OR(context, (OR) semanticObject); 
				return; 
			case RobotPackage.PROGRAM:
				sequence_Program(context, (Program) semanticObject); 
				return; 
			case RobotPackage.RFUNCTION:
				sequence_RFunction(context, (RFunction) semanticObject); 
				return; 
			case RobotPackage.RIGHT:
				sequence_Right(context, (Right) semanticObject); 
				return; 
			case RobotPackage.TRUE:
				sequence_TRUE(context, (TRUE) semanticObject); 
				return; 
			case RobotPackage.TIME_SENSOR:
				sequence_TimeSensor(context, (TimeSensor) semanticObject); 
				return; 
			case RobotPackage.VAR:
				sequence_Var(context, (Var) semanticObject); 
				return; 
			case RobotPackage.VAR_IDENTIFIER:
				sequence_VarIdentifier(context, (VarIdentifier) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns AND
	 *     Expression returns AND
	 *     BooleanExpression returns AND
	 *     AND returns AND
	 *
	 * Constraint:
	 *     {AND}
	 * </pre>
	 */
	protected void sequence_AND(ISerializationContext context, AND semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns Add
	 *     Expression returns Add
	 *     Add returns Add
	 *
	 * Constraint:
	 *     (expression+=Expression expression+=Expression*)
	 * </pre>
	 */
	protected void sequence_Add(ISerializationContext context, Add semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns Backward
	 *     Backward returns Backward
	 *
	 * Constraint:
	 *     distance=Distance
	 * </pre>
	 */
	protected void sequence_Backward(ISerializationContext context, Backward semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobotPackage.Literals.MOVEMENT__DISTANCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobotPackage.Literals.MOVEMENT__DISTANCE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBackwardAccess().getDistanceDistanceParserRuleCall_3_0(), semanticObject.getDistance());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns Block
	 *     Block returns Block
	 *
	 * Constraint:
	 *     (statement+=Statement statement+=Statement*)?
	 * </pre>
	 */
	protected void sequence_Block(ISerializationContext context, Block semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns CallFunction
	 *     Expression returns CallFunction
	 *     CallFunction returns CallFunction
	 *
	 * Constraint:
	 *     (functionidentifier=[FunctionIdentifier|EString] (parameters+=Expression parameters+=Expression*)?)
	 * </pre>
	 */
	protected void sequence_CallFunction(ISerializationContext context, CallFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns CallVar
	 *     Expression returns CallVar
	 *     CallVar returns CallVar
	 *
	 * Constraint:
	 *     varidentifier=[VarIdentifier|EString]
	 * </pre>
	 */
	protected void sequence_CallVar(ISerializationContext context, CallVar semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobotPackage.Literals.CALL_VAR__VARIDENTIFIER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobotPackage.Literals.CALL_VAR__VARIDENTIFIER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCallVarAccess().getVaridentifierVarIdentifierEStringParserRuleCall_3_0_1(), semanticObject.eGet(RobotPackage.Literals.CALL_VAR__VARIDENTIFIER, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns Clock
	 *     Clock returns Clock
	 *
	 * Constraint:
	 *     angle=EInt?
	 * </pre>
	 */
	protected void sequence_Clock(ISerializationContext context, Clock semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Unit returns Cm
	 *     Cm returns Cm
	 *
	 * Constraint:
	 *     {Cm}
	 * </pre>
	 */
	protected void sequence_Cm(ISerializationContext context, Cm semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns Condition
	 *     Condition returns Condition
	 *
	 * Constraint:
	 *     (Condition=BooleanExpression then=Statement else=Statement?)
	 * </pre>
	 */
	protected void sequence_Condition(ISerializationContext context, Condition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns Const
	 *     Expression returns Const
	 *     Const returns Const
	 *
	 * Constraint:
	 *     value=EInt?
	 * </pre>
	 */
	protected void sequence_Const(ISerializationContext context, Const semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns DistanceSensor
	 *     Expression returns DistanceSensor
	 *     DistanceSensor returns DistanceSensor
	 *
	 * Constraint:
	 *     distance=Distance
	 * </pre>
	 */
	protected void sequence_DistanceSensor(ISerializationContext context, DistanceSensor semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobotPackage.Literals.DISTANCE_SENSOR__DISTANCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobotPackage.Literals.DISTANCE_SENSOR__DISTANCE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDistanceSensorAccess().getDistanceDistanceParserRuleCall_3_0(), semanticObject.getDistance());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns Distance
	 *     Expression returns Distance
	 *     Distance returns Distance
	 *
	 * Constraint:
	 *     (valeur=EInt? unit=Unit)
	 * </pre>
	 */
	protected void sequence_Distance(ISerializationContext context, Distance semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns Div
	 *     Expression returns Div
	 *     Div returns Div
	 *
	 * Constraint:
	 *     (expression+=Expression expression+=Expression*)
	 * </pre>
	 */
	protected void sequence_Div(ISerializationContext context, Div semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns Equals
	 *     Expression returns Equals
	 *     Equals returns Equals
	 *
	 * Constraint:
	 *     (expression+=Expression expression+=Expression*)
	 * </pre>
	 */
	protected void sequence_Equals(ISerializationContext context, Equals semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns FALSE
	 *     Expression returns FALSE
	 *     BooleanExpression returns FALSE
	 *     FALSE returns FALSE
	 *
	 * Constraint:
	 *     {FALSE}
	 * </pre>
	 */
	protected void sequence_FALSE(ISerializationContext context, FALSE semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns Forward
	 *     Forward returns Forward
	 *
	 * Constraint:
	 *     distance=Distance
	 * </pre>
	 */
	protected void sequence_Forward(ISerializationContext context, Forward semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobotPackage.Literals.MOVEMENT__DISTANCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobotPackage.Literals.MOVEMENT__DISTANCE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getForwardAccess().getDistanceDistanceParserRuleCall_3_0(), semanticObject.getDistance());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FunctionIdentifier returns FunctionIdentifier
	 *
	 * Constraint:
	 *     name=EString
	 * </pre>
	 */
	protected void sequence_FunctionIdentifier(ISerializationContext context, FunctionIdentifier semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobotPackage.Literals.FUNCTION_IDENTIFIER__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobotPackage.Literals.FUNCTION_IDENTIFIER__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFunctionIdentifierAccess().getNameEStringParserRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns Greater
	 *     Expression returns Greater
	 *     Greater returns Greater
	 *
	 * Constraint:
	 *     (expression+=Expression expression+=Expression*)
	 * </pre>
	 */
	protected void sequence_Greater(ISerializationContext context, Greater semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns Left
	 *     Left returns Left
	 *
	 * Constraint:
	 *     distance=Distance
	 * </pre>
	 */
	protected void sequence_Left(ISerializationContext context, Left semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobotPackage.Literals.MOVEMENT__DISTANCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobotPackage.Literals.MOVEMENT__DISTANCE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLeftAccess().getDistanceDistanceParserRuleCall_3_0(), semanticObject.getDistance());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns Lesser
	 *     Expression returns Lesser
	 *     Lesser returns Lesser
	 *
	 * Constraint:
	 *     (expression+=Expression expression+=Expression*)
	 * </pre>
	 */
	protected void sequence_Lesser(ISerializationContext context, Lesser semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns Loop
	 *     Loop returns Loop
	 *
	 * Constraint:
	 *     (Condition=BooleanExpression statement=Statement)
	 * </pre>
	 */
	protected void sequence_Loop(ISerializationContext context, Loop semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobotPackage.Literals.STRUCTURE__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobotPackage.Literals.STRUCTURE__CONDITION));
			if (transientValues.isValueTransient(semanticObject, RobotPackage.Literals.LOOP__STATEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobotPackage.Literals.LOOP__STATEMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLoopAccess().getConditionBooleanExpressionParserRuleCall_3_0(), semanticObject.getCondition());
		feeder.accept(grammarAccess.getLoopAccess().getStatementStatementParserRuleCall_5_0(), semanticObject.getStatement());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns Minus
	 *     Expression returns Minus
	 *     Minus returns Minus
	 *
	 * Constraint:
	 *     (expression+=Expression expression+=Expression*)
	 * </pre>
	 */
	protected void sequence_Minus(ISerializationContext context, Minus semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Unit returns Mm
	 *     Mm returns Mm
	 *
	 * Constraint:
	 *     {Mm}
	 * </pre>
	 */
	protected void sequence_Mm(ISerializationContext context, Mm semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns Mul
	 *     Expression returns Mul
	 *     Mul returns Mul
	 *
	 * Constraint:
	 *     (expression+=Expression expression+=Expression*)
	 * </pre>
	 */
	protected void sequence_Mul(ISerializationContext context, Mul semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns NOT
	 *     Expression returns NOT
	 *     BooleanExpression returns NOT
	 *     NOT returns NOT
	 *
	 * Constraint:
	 *     {NOT}
	 * </pre>
	 */
	protected void sequence_NOT(ISerializationContext context, NOT semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns OR
	 *     Expression returns OR
	 *     BooleanExpression returns OR
	 *     OR returns OR
	 *
	 * Constraint:
	 *     {OR}
	 * </pre>
	 */
	protected void sequence_OR(ISerializationContext context, OR semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Program returns Program
	 *
	 * Constraint:
	 *     (function+=RFunction function+=RFunction*)?
	 * </pre>
	 */
	protected void sequence_Program(ISerializationContext context, Program semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RFunction returns RFunction
	 *
	 * Constraint:
	 *     (functionidentifier=FunctionIdentifier (block+=Block block+=Block*)?)
	 * </pre>
	 */
	protected void sequence_RFunction(ISerializationContext context, RFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns Right
	 *     Right returns Right
	 *
	 * Constraint:
	 *     distance=Distance
	 * </pre>
	 */
	protected void sequence_Right(ISerializationContext context, Right semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobotPackage.Literals.MOVEMENT__DISTANCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobotPackage.Literals.MOVEMENT__DISTANCE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRightAccess().getDistanceDistanceParserRuleCall_3_0(), semanticObject.getDistance());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns TRUE
	 *     Expression returns TRUE
	 *     BooleanExpression returns TRUE
	 *     TRUE returns TRUE
	 *
	 * Constraint:
	 *     {TRUE}
	 * </pre>
	 */
	protected void sequence_TRUE(ISerializationContext context, TRUE semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns TimeSensor
	 *     Expression returns TimeSensor
	 *     TimeSensor returns TimeSensor
	 *
	 * Constraint:
	 *     CurrentMillis=EInt?
	 * </pre>
	 */
	protected void sequence_TimeSensor(ISerializationContext context, TimeSensor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     VarIdentifier returns VarIdentifier
	 *
	 * Constraint:
	 *     name=EString
	 * </pre>
	 */
	protected void sequence_VarIdentifier(ISerializationContext context, VarIdentifier semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobotPackage.Literals.VAR_IDENTIFIER__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobotPackage.Literals.VAR_IDENTIFIER__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVarIdentifierAccess().getNameEStringParserRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns Var
	 *     Var returns Var
	 *
	 * Constraint:
	 *     (varidentifier=VarIdentifier expression=Expression)
	 * </pre>
	 */
	protected void sequence_Var(ISerializationContext context, Var semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobotPackage.Literals.VAR__VARIDENTIFIER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobotPackage.Literals.VAR__VARIDENTIFIER));
			if (transientValues.isValueTransient(semanticObject, RobotPackage.Literals.VAR__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobotPackage.Literals.VAR__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVarAccess().getVaridentifierVarIdentifierParserRuleCall_3_0(), semanticObject.getVaridentifier());
		feeder.accept(grammarAccess.getVarAccess().getExpressionExpressionParserRuleCall_5_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
}
